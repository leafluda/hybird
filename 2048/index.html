<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048</title>
    <style>
#app{
    top: 40%;
    left: 50%;
    transform: translate(-50%,-50%);
    position: relative;
    width: 590px;       
    height: 590px;
    background: #AA076B;  /* fallback for old browsers */
    background: -webkit-linear-gradient(to right, #61045F, #AA076B);  /* Chrome 10-25, Safari 5.1-6 */
    background: linear-gradient(to right, #61045F, #AA076B); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
    display: none;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr 1fr;
    grid-gap: 10px;
    padding : 10px;     
    border-radius: 20;      
}

#unstart{
    top: 40%;
    left: 50%;
    transform: translate(-50%,-50%);
    position: relative;
    width: 590px;       
    height: 590px;
    background: #43c6ac; /* fallback for old browsers */
    background: -webkit-linear-gradient(to right, #43c6ac, #f8ffae); /* Chrome 10-25, Safari 5.1-6 */
    background: linear-gradient(to right, #43c6ac, #f8ffae); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
    grid-gap: 10px;
    padding : 10px;  
    border-radius: 20;
    font-size: 50;
    line-height : 500px;
    text-align: center;
    font-family: 'Roboto', sans-serif;
    text-transform: uppercase;
}

#win{
    top: 40%;
    left: 50%;
    transform: translate(-50%,-50%);
    position: relative;
    display: none;
    width: 590px;       
    height: 590px;
    grid-gap: 10px;
    padding : 10px;  
    background: #fceabb;  /* fallback for old browsers */
    background: -webkit-linear-gradient(to right, #f8b500, #fceabb);  /* Chrome 10-25, Safari 5.1-6 */
    background: linear-gradient(to right, #f8b500, #fceabb); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
    border-radius: 20;
    font-size: 50;
    line-height : 500px;
    text-align: center;
    font-family: 'Roboto', sans-serif;
    text-transform: uppercase;      
}

#gameo{
    top: 40%;
    left: 50%;
    transform: translate(-50%,-50%);
    position: relative;
    display: none;
    width: 590px;       
    height: 590px;
    grid-gap: 10px;
    padding : 10px;
    color : #ffffff;
    background: #000000;  /* fallback for old browsers */
    background: -webkit-linear-gradient(to right, #434343, #000000);  /* Chrome 10-25, Safari 5.1-6 */
    background: linear-gradient(to right, #434343, #000000); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
    border-radius: 20;
    font-size: 50;
    line-height : 500px;
    text-align: center;
    font-family: 'Roboto', sans-serif;
    text-transform: uppercase;  
}

#UI{
    top: 20%;
    left: 50%;
    transform: translate(-50%,-50%);
    position: relative;
    width: 590px;
    height: 100px;
    background: #43c6ac; /* fallback for old browsers */
    background: -webkit-linear-gradient(to right, #43c6ac, #f8ffae); /* Chrome 10-25, Safari 5.1-6 */
    background: linear-gradient(to right, #43c6ac, #f8ffae); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
    grid-gap: 10px;
    grid-gap: 10px;
    padding : 10px;     
    border-radius: 20; 
}

#scoretext{
    left: 13%;
    position: relative;
    font-size: 30px;
    font-family: 'Roboto', sans-serif;
    text-transform: uppercase;
}

#scoreboard{
    left: 5%;
    position: relative;
    font-size: 30px;
    font-family: 'Roboto', sans-serif;
    text-transform: uppercase;
}

.bg{            
    background: #43c6ac; /* fallback for old browsers */
    background: -webkit-linear-gradient(to right, #43c6ac, #f8ffae); /* Chrome 10-25, Safari 5.1-6 */
    background: linear-gradient(to right, #43c6ac, #f8ffae); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
    text-align: center;   
    line-height: 1.8;
    font-size: 70;
    font-family: cursive;
    border-radius: 20;
}

.block{
    position: absolute;
    left: 20;
    top: 20;
    width: 120;
    height: 120;
    background-color: rgb(234, 234, 234);
    text-align: center;
    font-size: 30;            
    line-height: 1.6;
    line-height : 120px;
    font-family: 'Roboto', sans-serif;
    text-transform: uppercase;      
    border-radius: 20;
}

.wrap {
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.button {
  width: 140px;
  height: 45px;
  font-family: 'Roboto', sans-serif;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 2.5px;
  font-weight: 500;
  color: #000;
  background-color: #fff;
  border: none;
  border-radius: 45px;
  box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease 0s;
  cursor: pointer;
  outline: none;
  margin: 10px;
}

.button:hover {
  background-color: #2e3ae5;
  box-shadow: 0px 15px 20px rgba(46, 49, 229, 0.397);
  color: #fff;
  transform: translateY(-7px);
}
    </style>
</head>
<body onload="openfile()">
    
    <div id="UI">                                                                                           <!-- UI -->
        <div class="wrap">
            <button class="button" onclick="start()">Start</button> <!-- 스타트 버튼 -->
            <button class="button" onclick="undo()">undo</button> <!-- 스타트 버튼 -->
            <p id = "scoreboard">score<p id = "scoretext"></p> </p>       <!-- 스코어 -->                                                      
          </div>                                                                                                                                                               
    </div>
    <div id="unstart">Click Start Button</div>                                                              <!-- 게임시작전 화면 -->
    <div id="app">                                                                                          <!-- 게임화면 -->
        <div class="bg"></div>
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
        <div class="bg"></div> 
    </div>
    <div id="win">You Win</div>                                                                             <!-- 2048완성시 출력화면 -->
    <div id="gameo">You Lose</div>                                                                          <!-- 더이상 이동할 수 없을시 출력 화면 -->
    <script>

    var board = [[0,0,0,0], // 화면출력, 블럭이동등 커맨드에 사용되는 배열
                 [0,0,0,0],
                 [0,0,0,0],
                 [0,0,0,0]];

    var temp = [[0,0,0,0], // 화면출력, 블럭이동등 커맨드에 사용되는 배열
                [0,0,0,0],
                [0,0,0,0],
                [0,0,0,0]];

    var check = [[0,0,0,0], // 블럭이동확인, 애니메이션등 커맨드에 사용되는 배열
                 [0,0,0,0],
                 [0,0,0,0],
                 [0,0,0,0]];
    
    var undoboard = [[0,0,0,0], // 뒤로가기 기능을 사용할 수 있게 이전보드를 저장해주는 배열
                     [0,0,0,0],
                     [0,0,0,0],
                     [0,0,0,0]];

    var gamestate = true; // 게임이 끝났다면 키입력이 안되도록 막거나, 게임이 끝났는지 확인하는 커맨드에 사용되는 변수

    var gameover = false; // 게임이 끝났는지 확인하는 커맨드에 사용되는 변수

    var score = 0; // 스코어로 사용되며 커맨드에 사용되는 변수

    var gamewin = false; // 2048을 완성했는지, 여부를 저장하며 커맨드에 사용되는 변수

    var blocks; // class 'block'인 div를 저장하며 커맨드에 사용되는 배열

    var scoretext; // id 'scoretext'인 요소를 저장하며 커맨드에 사용되는 변수
    
    var move = false; // 이동했는지를 확인하며 커맨드에 사용되는 변수

    var moveLpx = [[0,0,0,0], // 블럭의 좌우 이동에 사용되며 커맨드에 사용되는 배열
                  [0,0,0,0],
                  [0,0,0,0],
                  [0,0,0,0]];

    var moveTpx = [[0,0,0,0], // 블럭의 상하 이동에 사용되며 커맨드에 사용되는 배열
                  [0,0,0,0],
                  [0,0,0,0],
                  [0,0,0,0]];
    
    var moveComplete = [[0,0,0,0], // 블럭이 이동해 도착할 위치를 저장하며 커맨드에 사용되는 배열
                        [0,0,0,0],
                        [0,0,0,0],
                        [0,0,0,0]];

    var moveYAfter = [[0,0,0,0], // 블럭의 배열상 도착할 위치를 저장하먀 커맨드에 사용되는 배열
                      [0,0,0,0],
                      [0,0,0,0],
                      [0,0,0,0]];
                     
    var moveXAfter = [[0,0,0,0], // 블럭의 배열상 도착할 위치를 저장하먀 커맨드에 사용되는 배열
                      [0,0,0,0],
                      [0,0,0,0],
                      [0,0,0,0]];

    var scaleblock = [[0,0,0,0], // 애니메이션으로 블럭의 크기를 바꿔줄때 사용하는 배열
                      [0,0,0,0],
                      [0,0,0,0],
                      [0,0,0,0]];

    var checkblock =  [[0,0,0,0], // 애니메이션으로 새로운 블럭이 생겼을때 사용하는 배열
                      [0,0,0,0],
                      [0,0,0,0],
                      [0,0,0,0]];

    var intervalId; // 애니메이션은 setinterval해 반복하기 위한 변수
    
    var onoff = false; // 커맨드를 동시입력해 오류가 발생하는걸 막기위한 변수

        function compute(key){ // Q.2 이동 연산 커맨드 및, 키 커맨드
            move = false;

            for(let x = 0; x < 4 ; x++){
                for(let y = 0; y < 4; y++){
                    undoboard[x][y] = board[x][y];
                    temp[x][y] = 0;
                    check[x][y] = board[x][y];
                    moveYAfter[x][y] = -1;
                    moveXAfter[x][y] = -1;
                }
            }
            
            switch (key) { 
            case 'c' : // 게임종료 확인 디버깅키
            board = [[2,4,2,4],
                     [4,2,4,2],
                     [2,4,2,4],
                     [4,2,4,2]];
            break;
            case 'w' : // 게임종료 확인 디버깅키
            board[0][0] = 2048;
            break;
            case 'ArrowRight': // 오른쪽 화살표 키를 누를경우 이동가능한 블럭들이 이동하며 한번만 합쳐짐
                for(let x = 0; x < 4 ; x++){
                    var a = 3;
                    for(let y = 3; y > -1 ; y--){ 
                        if(board[x][y] !=0){
                            if(temp[x][a]==0){
                                temp[x][a] = board[x][y];
                                moveYAfter[x][y] = a;
                            }
                        a--;
                        }
                    }
                }

                for(let x = 0; x < 4 ; x++){
                    for(let y = 2; y > -1; y--){ 
                        for(let z = 3; z > y; z--){
                            if(moveYAfter[x][z]-moveYAfter[x][y]==1){
                                if(board[x][y]==board[x][z]){
                                    moveYAfter[x][y] = moveYAfter[x][z];
                                } 
                            }
                        }
                        if(temp[x][y]!=0){
                            if(temp[x][y]==temp[x][y+1]){
                            temp[x][y+1] = temp[x][y+1] + temp[x][y];
                            temp[x][y] = 0;
                            }
                        }
                    }
                }
                for(let x = 0; x < 4 ; x++){ //버그 예외처리
                    for(let y = 0; y < 4; y++){ 
                        board[x][y] = 0;
                    }
                    if(check[x][3]==check[x][2]&&check[x][2]==check[x][1]&&check[x][1]!=0){
                        if(check[x][1]==check[x][0]){
                            for(let i =0; i<2; i++){
                            moveYAfter[x][i] = 2;
                            moveYAfter[x][i+2] = 3;
                            }
                        }else if(check[x][1]!=check[x][0]){
                            moveYAfter[x][2]=3;
                            moveYAfter[x][1]=2;
                            moveYAfter[x][0]=1;
                        }
                    }else if(check[x][2]==check[x][1]&&check[x][1]!=0){
                        if(check[x][3]!=0){
                            moveYAfter[x][2] = 2
                            moveYAfter[x][1] = 2
                            if(check[x][0]!=0){
                                moveYAfter[x][0] = 1
                            }
                        }else{
                            moveYAfter[x][2] = 3
                            moveYAfter[x][1] = 3
                            if(check[x][0]!=0){
                                moveYAfter[x][0] = 2
                            }
                        }
                    }else if(check[x][3]==check[x][2]&&check[x][2]!=0){
                        if(check[x][1]!=0&&check[x][0]!=check[x][1]){
                            moveYAfter[x][0] = 1
                            moveYAfter[x][1] = 2
                        }else{
                            moveYAfter[x][0] = 2
                            moveYAfter[x][1] = 2
                            moveYAfter[x][2] = 3
                        }
                    }else if(check[x][3]==check[x][1]&&check[x][1]!=0&&check[x][2]!=check[x][3]){
                        if(check[x][2]==0){
                            moveYAfter[x][3] = 3
                            moveYAfter[x][1] = 3
                            moveYAfter[x][0] = 2
                        }
                    }else{
                        if(temp[x][1]!=0){
                            if(temp[x][2]==0){
                                moveYAfter[x][1]=2;
                                temp[x][2]=temp[x][1];
                                temp[x][1]=0;
                            }
                        }
                        if(temp[x][0]!=0){
                            if(temp[x][1]==0){
                                moveYAfter[x][0]=1;
                                if(temp[x][2]==0){
                                    moveYAfter[x][0]=2;
                                }
                            }
                        }
                    }
                }

                for(let x = 0; x < 4 ; x++){
                    var a = 3;
                    for(let y = 3; y > -1 ; y--){ 
                        if(temp[x][y] !=0){
                            if(board[x][a]==0){
                                board[x][a] = temp[x][y];
                            }
                        a--;
                        }
                    }
                }
                resetpx();
                intervalId = setInterval(rightAnimation,1);
                break;
            case 'ArrowLeft': // 왼쪽 화살표 키를 누를경우 이동가능한 블럭들이 이동하며 한번만 합쳐짐
                for(let x = 0; x < 4 ; x++){
                    var a = 0;
                    for(let y = 0; y < 4; y++){ 
                        if(board[x][y] !=0){
                            if(temp[x][a]==0){
                                temp[x][a] = board[x][y]; 
                                moveYAfter[x][y] = a;
                            }
                        a++;
                        }
                    }
                }

                for(let x = 0; x < 4 ; x++){
                    for(let y = 1; y < 4; y++){
                        for(let z = 0; z < y; z++){
                            if(moveYAfter[x][y]-moveYAfter[x][z]==1){
                                if(board[x][y]==board[x][z]){
                                    moveYAfter[x][y] = moveYAfter[x][z];
                                } 
                            }
                        }
                        if(temp[x][y]!=0){
                            if(temp[x][y]==temp[x][y-1]){
                                temp[x][y-1] = temp[x][y-1] + temp[x][y];
                                temp[x][y] = 0;
                            }
                        }
                    }
                }

                for(let x = 0; x < 4 ; x++){//버그 예외처리
                    for(let y = 0; y < 4; y++){       
                        board[x][y] = 0; 
                    }
                    if(check[x][0]==0){
                        if(temp[x][2]!=0){
                            if(temp[x][1]==0){
                                moveYAfter[x][3]=moveYAfter[x][3]-1;
                                temp[x][1]=temp[x][2];
                                temp[x][2]=0;
                            }
                        }
                    }else if(check[x][0]==check[x][1]&&check[x][1]==check[x][2]&&check[x][1]!=0){
                        if(check[x][2]==check[x][3]){
                            for(let i =0; i<2; i++){
                            moveYAfter[x][i] = 0;
                            moveYAfter[x][i+2] = 1;
                            }
                        }else if(check[x][2]!=check[x][3])
                        {
                            moveYAfter[x][1]=0;
                            moveYAfter[x][2]=1;
                            moveYAfter[x][3]=2;
                        }
                    }else if(check[x][0]==check[x][2]&&check[x][1]==0){
                            moveYAfter[x][0] = 0;
                            moveYAfter[x][2] = 0;
                            if(check[x][3]!=0)
                            {
                                moveYAfter[x][3] = 1;
                            }
                    }else if(check[x][0]==check[x][1]&&check[x][0]!=0){
                        if(check[x][2]==0){
                            moveYAfter[x][0] = 0;
                            moveYAfter[x][1] = 0;
                            if(check[x][3]!=0)
                            {
                                moveYAfter[x][3] = 1;
                            }
                        }
                        if(check[x][1]!=check[x][2]&&check[x][2]!=0){
                            moveYAfter[x][0] = 0;
                            moveYAfter[x][1] = 0;
                            moveYAfter[x][2] = 1;
                            if(check[x][3]==check[x][2])
                            {
                                moveYAfter[x][3] = 1;
                            }else{
                                moveYAfter[x][3] = 2;
                            }
                        }     
                    }else{
                        if(temp[x][2]!=0){
                            if(temp[x][1]==0){
                                moveYAfter[x][2]=moveYAfter[x][2]-1;
                                temp[x][1]=temp[x][2];
                                temp[x][2]=0;
                            }
                        }
                        if(temp[x][3]!=0){
                            if(temp[x][2]==0){
                                moveYAfter[x][3]=moveYAfter[x][3]-1;
                                if(temp[x][1]==0){
                                    moveYAfter[x][3]=moveYAfter[x][3]-1;
                                }
                            }
                        }
                    }   
                }

                for(let x = 0; x < 4 ; x++){
                    var a = 0;
                    for(let y = 0; y < 4; y++){ 
                        if(temp[x][y] !=0){
                            if(board[x][a]==0){
                                board[x][a] = temp[x][y];
                            }
                        a++;
                        }
                    }
                }

                resetpx();
                intervalId = setInterval(LeftAnimation,1);
                break;
            case 'ArrowUp': // 위쪽 화살표 키를 누를경우 이동가능한 블럭들이 이동하며 한번만 합쳐짐
                for(let y = 0; y < 4 ; y++){
                    var a = 0;
                    for(let x = 0; x < 4; x++){ 
                        if(board[x][y] !=0){
                            if(temp[a][y]==0){
                                temp[a][y] = board[x][y]; 
                                moveXAfter[x][y] = a; 
                            }
                        a++;
                        }
                    }
                }

                for(let y = 0; y < 4 ; y++){
                    for(let x = 1; x < 4; x++){
                        for(let z = 0; z < x; z++){
                            if(moveXAfter[x][y]-moveXAfter[z][y]==1){
                                if(board[x][y]==board[z][y]){
                                    moveXAfter[x][y] = moveXAfter[z][y];
                                } 
                            }
                        }
                        if(temp[x][y]!=0){
                            if(temp[x][y]==temp[x-1][y]){
                                temp[x-1][y] = temp[x-1][y] + temp[x][y];
                                temp[x][y] = 0;
                            }
                        }
                        
                    }
                }

                for(let y = 0; y < 4 ; y++){ //버그 예외처리
                    for(let x = 0; x < 4; x++){
                    board[x][y] = 0;
                    }
                    if(check[0][y]==0){
                        if(temp[2][y]!=0){
                            if(temp[1][y]==0){
                                moveXAfter[3][y]=moveXAfter[3][y]-1;
                                temp[1][y]=temp[2][y];
                                temp[2][y]=0;
                            }
                        }
                    }else if(check[0][y]==check[1][y]&&check[1][y]==check[2][y]&&check[1][y]!=0){
                        if(check[2][y]==check[3][y]){
                            for(let i =0; i<2; i++){
                            moveXAfter[i][y] = 0;
                            moveXAfter[i+2][y] = 1;
                            }
                        }else if(check[2][y]!=check[3][y])
                        {
                            moveXAfter[1][y]=0;
                            moveXAfter[2][y]=1;
                            moveXAfter[3][y]=2;
                        }
                        
                    }else if(check[0][y]==check[2][y]&&check[1][y]==0){
                            moveXAfter[0][y] = 0;
                            moveXAfter[2][y] = 0;
                            if(check[3][y]!=0)
                            {
                                moveXAfter[3][y] = 1;
                            }
                    }else if(check[0][y]!=0&&check[0][y]==check[1][y]&&check[2][y]==0){
                            moveXAfter[0][y] = 0;
                            moveXAfter[1][y] = 0;
                            moveXAfter[3][y] = 1;
                    }else if(check[0][y]!=0&&check[1][y]==check[3][y]&&check[2][y]==0){
                            moveXAfter[0][y] = 0;
                            moveXAfter[1][y] = 1;
                            moveXAfter[3][y] = 1;
                    }else if(check[0][y]!=0&&check[2][y]==check[3][y]&&check[1][y]!=0&&check[1][y]!=check[0][y]){ 
                            moveXAfter[3][y] = 2;
                    }else if(check[1][y]==check[2][y]&&check[1][y]!=0){
                            if(check[0][y]!=0){
                                moveXAfter[1][y] = 1;
                                moveXAfter[2][y] = 1; 
                                    if(check[3][y]!=0)
                                    {
                                    moveXAfter[3][y] = 2;
                                    }
                            }else{
                                moveXAfter[1][y] = 0;
                                moveXAfter[2][y] = 0;
                                    if(check[3][y]!=0)
                                    {
                                    moveXAfter[3][y] = 1;
                                    }
                            }      
                    }else if(check[0][y]==check[1][y]&&check[0][y]!=0){
                        if(check[2][y]==0){
                            moveXAfter[0][y] = 0;
                            moveXAfter[1][y] = 0;
                            if(check[3][y]!=0)
                            {
                                moveXAfter[3][y] = 1;
                            }
                        }else if(check[1][y]!=check[2][y]&&check[2][y]!=0){
                            moveXAfter[0][y] = 0;
                            moveXAfter[1][y] = 0;
                            moveXAfter[2][y] = 1;
                            if(check[3][y]==check[2][y])
                            {
                                moveXAfter[3][y] = 1;
                            }else{
                                moveXAfter[3][y] = 2;
                            }
                        }     
                    }else{
                        if(temp[2][y]!=0){
                            if(temp[1][y]==0){
                                moveXAfter[2][y]=moveXAfter[2][y]-1;
                                temp[1][y]=temp[2][y];
                                temp[2][y]=0;
                            }
                        }
                        if(temp[3][y]!=0){
                            if(temp[2][y]==0){
                                moveXAfter[3][y]=moveXAfter[3][y]-1;
                                if(temp[1][y]==0){
                                    moveXAfter[3][y]=moveXAfter[3][y]-1;
                                }
                            }
                        }
                    }
                    if(check[0][0]==check[3][0]){
                        if(check[1][0]==check[2][0]&&check[1][0]==0){
                            moveXAfter[3][0] = 0;
                        }
                    }
                }

                for(let y = 0; y < 4 ; y++){
                    var a = 0;
                    for(let x = 0; x < 4; x++){ 
                        if(temp[x][y] !=0){
                            if(board[a][y]==0){
                                board[a][y] = temp[x][y];
                            }
                            a++;
                        }
                    }
                }
                resetpx();
                intervalId = setInterval(upAnimation,1);
                break;
            case 'ArrowDown': // 아래쪽 화살표 키를 누를경우 이동가능한 블럭들이 이동하며 한번만 합쳐짐
                for(let y = 0; y < 4 ; y++){
                    var a = 3;
                    for(let x = 3; x > -1; x--){ 
                        if(board[x][y] !=0){
                            if(temp[a][y]==0){
                                temp[a][y] = board[x][y];
                                moveXAfter[x][y] = a;
                            }
                            a--;
                        }
                    }
                }

                for(let y = 0; y < 4 ; y++){
                    for(let x = 2; x > -1; x--){
                        for(let z = 3; z > x; z--){
                            if((moveXAfter[x][y]-moveXAfter[z][y])==-1){
                                if(board[x][y]==board[z][y]&&board[z][y]!=0){
                                    moveXAfter[x][y] = moveXAfter[z][y];
                                } 
                            }
                        }
                        if(temp[x][y]==temp[x+1][y]){
                            temp[x+1][y] = temp[x+1][y] + temp[x][y];
                            temp[x][y] = 0;

                        }
                    }
                }

                for(let y= 0; y < 4 ; y++){//버그 예외처리
                    for(let x = 0; x < 4; x++){ 
                        board[x][y] = 0;
                    }if(check[3][y]==check[2][y]&&check[2][y]!=0){
                        if(moveXAfter[1][y]!=0){
                            moveXAfter[1][y] = 2;
                            if(moveXAfter[0][y]==moveXAfter[1][y]){
                                moveXAfter[0][y] = 2;
                            }else{
                                moveXAfter[0][y] = 1;
                            }
                        }else{
                            moveXAfter[0][y] = 2;
                            moveXAfter[1][y] = 2;
                        }
                    }else if(check[3][y]==check[1][y]&&check[1][y]!=0&&check[2][y]==0){
                        moveXAfter[0][y] = 2;
                    }else if(check[2][y]==check[1][y]){
                        if(check[2][y]==0)
                        {
                            if(check[3][y]==0)
                            {
                                moveXAfter[0][y] = 3;
                            }
                        }else{
                            if(check[3][y]==0)
                            {
                                moveXAfter[0][y] = 2;
                                moveXAfter[1][y] = 3;
                                moveXAfter[2][y] = 3;
                            }else{
                                moveXAfter[0][y] = 1;
                                moveXAfter[1][y] = 2;
                                moveXAfter[2][y] = 2;
                            }
                        }
                    }
                }

                for(let y = 0; y < 4 ; y++){
                    var a = 3;
                    for(let x = 3; x > -1; x--){ 
                        if(temp[x][y] !=0){
                            if(board[a][y]==0){0
                                board[a][y] = temp[x][y];
                            }
                            a--;
                        }
                    }
                }
                resetpx();
                intervalId = setInterval(downAnimation,1);
                break;
            }
        }

        function boardcheck(){ // Q.2 새로운 블럭이 생성되었는지 체크해줄때 사용하는커맨드
            for(let x = 0; x < 4 ; x++){
                for(let y = 0; y < 4; y++){
                    checkblock[x][y] = board[x][y];
                }
            }
        }

        function endG(){  // Q.2 게임이 끝나는지(2048완성 or 더이상 이동할 수 없는경우)를 체크해 끝나는경우에 맞는 화면 출력하는 커맨드
            var rl = false;
            var ud = false;

            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    if(board[i][j]==2048){
                        gamestate = false;
                        gamewin = true;
                        var app = document.getElementById('app');
                        var unstart = document.getElementById('unstart');
                        var win = document.getElementById('win');
                        var gameo = document.getElementById('gameo');

                        app.style.display = 'none';
                        unstart.style.display = 'none';
                        win.style.display = 'grid';
                        gameo.style.display = 'none';
                    }
                }
            }

            if(gamewin == false){
                if(gameover==true){
                    gamestate = false;
                    var app = document.getElementById('app');
                    var unstart = document.getElementById('unstart');
                    var win = document.getElementById('win');
                    var gameo = document.getElementById('gameo');

                    app.style.display = 'none';
                    unstart.style.display = 'none';
                    win.style.display = 'none';
                    gameo.style.display = 'grid';
                } 
        
                for(let i= 0; i<4;i++){
                    for(let j= 0; j<3;j++){
                        if(board[i][j] == board[i][j+1]){
                            rl = true;
                        }
                    }
                }

                for(let i= 0; i<3;i++){
                    for(let j= 0; j<4;j++){
                        if(board[i][j] == board[i+1][j]){
                            ud = true;
                        }
                    }
                }

                for(let i= 0; i<3;i++){
                    for(let j= 0; j<4;j++){
                        if(board[i][j] == 0){
                            rl = true;
                            ud = true;
                        }
                    }
                }

                if(rl==false){
                    if(ud==false){
                        gameover = true;
                    }
                } 

            }
        }

        function undo(){ // Q.2 undo 버튼 클릭시 이전 보드로 돌아가는 커맨드
            if(score >0){
                score = score - 1;
                scoretext = document.getElementById('scoretext');
                scoretext.innerText = score+""
                blocks = document.getElementsByClassName("block");

                for(let i= 0; i<4;i++){
                    for(let j= 0; j<4;j++){
                         blocks[(i*4)+j].innerText = undoboard[i][j]+ "";
                         board[i][j]=undoboard[i][j];
                        blocks[(i*4)+j].style.top = 20+(150*i);
                            blocks[(i*4)+j].style.left = 20+(150*j);
                switch (undoboard[i][j]) {
                case 0:
                    blocks[(i*4)+j].style.display = 'none';
                break;
                case 2:
                    blocks[(i*4)+j].style.display = 'block';
                    blocks[(i*4)+j].style.backgroundColor = '#FFD8D8';
                break;
                case 4:
                    blocks[(i*4)+j].style.display = 'block';
                    blocks[(i*4)+j].style.backgroundColor = '#FAE0C8';
                break;
                case 8:
                    blocks[(i*4)+j].style.display = 'block';
                    blocks[(i*4)+j].style.backgroundColor = '#FAF4C0';
                break;
                case 16:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#CEFBC9';
                break;
                case 32:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#D4F4FA';
                break;
                case 64:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#DAD9FF';
                break;
                case 128:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#E8D9FF';
                break;
                case 256:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#F15F5F';
                break;
                case 512:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#F2CB61';
                break;
                case 1024:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#E5D85C';
                break;
                case 2048:
                blocks[(i*4)+j].style.display = 'block';
                blocks[(i*4)+j].style.backgroundColor = '#86E57F';
                break;
            }
                }
            }
            }
            
        }
        
        function draw(){ // Q.2 이동 후, 또는 새로운 숫지2블럭이 배열에 생성되면, div의 style을 조정해 화면에 출력 하는 커맨드
            blocks = document.getElementsByClassName("block");
            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    blocks[(i*4)+j].innerText = board[i][j]+ "";
                    blocks[(i*4)+j].style.top = 20+(150*i);
                    blocks[(i*4)+j].style.left = 20+(150*j);
                        switch (board[i][j]) {
                            case 0:
                                blocks[(i*4)+j].style.display = 'none';
                            break;
                            case 2:
                                blocks[(i*4)+j].style.display = 'block';
                                blocks[(i*4)+j].style.backgroundColor = '#FFD8D8';
                            break;
                            case 4:
                                blocks[(i*4)+j].style.display = 'block';
                                blocks[(i*4)+j].style.backgroundColor = '#FAE0C8';
                            break;
                            case 8:
                                blocks[(i*4)+j].style.display = 'block';
                                blocks[(i*4)+j].style.backgroundColor = '#FAF4C0';
                            break;
                            case 16:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#CEFBC9';
                            break;
                            case 32:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#D4F4FA';
                            break;
                            case 64:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#A5B2FF';
                            break;
                            case 128:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#E8D9FF';
                            break;
                            case 256:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#F15F5F';
                            break;
                            case 512:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#F2CB61';
                            break;
                            case 1024:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#E5D85C';
                            break;
                            case 2048:
                            blocks[(i*4)+j].style.display = 'block';
                            blocks[(i*4)+j].style.backgroundColor = '#86E57F';
                            break;
                        }
                }
            }
            onoff=false;
        }

        function checkmove(){ // Q.2 블럭이 이동이 되었는지를 체크해주고, 
                              // 되었다면 스코어를 1 올려주는 커맨드
            for(let x = 0; x < 4 ; x++){
                for(let y = 0; y < 4; y++){ 
                    if(board[x][y]!=check[x][y]){
                        move = true;
                    }
                }
            }
            
            if(move == true){
                boardcheck();
                newblock();
                resetpx();
                intervalId = setInterval(newdrawAnimation,1);
                score = score + 1;
                scoretext = document.getElementById('scoretext');
                scoretext.innerText = score+""
                draw();
            }
        }

        function newblock(){ // Q.2 새로운 숫자2 블럭을 생성해주는 커맨드
            while(true){
                var x = parseInt(Math.random() * 3.99);
                var y = parseInt(Math.random() * 3.99);
                if(board[x][y]==0){   
                    board[x][y]= 2;
                    break;
                }
            }
        }

        function newblock4(){ //Q.2 게임 시작시, 숫자4블럭이 생성되야할 경우 생성해주는 커맨드
            while(true){
                var x = parseInt(Math.random() * 3.99);
                var y = parseInt(Math.random() * 3.99);
                if(board[x][y]==0){   
                    board[x][y]= 4;
                    break;
                }
            }
        }

        function first(){ //Q.2 게임 시작시, 숫자2,숫자4,숫자2,4 블럭 중 어떤 블럭으로 생성되는지 정해주는 커맨드
            var rand =  parseInt(Math.random() * 2.99);
            boardcheck();
            switch (rand) {
                case 0:
                    newblock();
                break;
                case 1:
                    newblock4();
                break;
                case 2:
                    newblock4();
                    newblock();
                break;
            }
            resetpx();
            intervalId = setInterval(newdrawAnimation,1);
        }

        function start(){ //Q.2 이전 데이터 들을 초기화 하고 게임 시작을 해주는 커맨드
            gamestate = true;
            gamewin = false;
            gameover = false;
            score = 0;
            var scoretext = document.getElementById('scoretext');
            scoretext.innerText = score+""
            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    board[i][j]=0;
                }
            }
            first();
            draw();


            var app = document.getElementById('app');
            var unstart = document.getElementById('unstart');
            var win = document.getElementById('win');
            var gameo = document.getElementById('gameo');

            app.style.display = 'grid';
            unstart.style.display = 'none';
            win.style.display = 'none';
            gameo.style.display = 'none';
        }

        function resetpx(){ //Q.2 애니메이션 커맨드에 필요한 데이터를 초기화 시켜주는 커맨드
            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    moveTpx[i][j] = 20+(150*i);
                    moveLpx[i][j] = 20+(150*j);
                    temp[i][j] = 0;
                    moveComplete[i][j] = 0;
                    scaleblock[i][j] = 0;
                }
            }
        }

        function LeftAnimation(){ // Q.2 왼쪽 방향키를 누를경우 이동되는 블럭들을 애니메이션으로 출력해주는 커맨드
            onoff = true;
            blocks = document.getElementsByClassName("block");
            
            var endani = 0;

            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    moveComplete[i][j] = 20+(150*moveYAfter[i][j]);
                }
            }

            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    if(check[i][j]!=0){
                        if(moveLpx[i][j]>=(moveComplete[i][j]+1)){
                            moveLpx[i][j] = moveLpx[i][j]-10;
                            blocks[(i*4)+j].style.left = moveLpx[i][j];
                            console.log("이동중");
                        }else{
                            temp[i][j] = 1;
                        }  
                    }else{
                        temp[i][j] = 1;
                    }
                    endani = endani + temp[i][j];
                }
            }
            if(endani==16){
                clearInterval(intervalId);
                console.log("끝");
                checkmove();
                draw();
            }
        }

        function rightAnimation(){ // Q.2 오른쪽 방향키를 누를경우 이동되는 블럭들을 애니메이션으로 출력해주는 커맨드
            onoff = true;
            blocks = document.getElementsByClassName("block");
            
            var endani = 0;
            
            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    moveComplete[i][j] = 20+(150*(moveYAfter[i][j]))
                }
            }

            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    if(check[i][j]!=0){
                        if(moveLpx[i][j]<=(moveComplete[i][j]-1)){
                            moveLpx[i][j] = moveLpx[i][j]+10;
                            blocks[(i*4)+j].style.left = moveLpx[i][j];
                            console.log("이동중");
                        }else{
                            temp[i][j] = 1;
                        }  
                    }else{
                        temp[i][j] = 1;
                    }
                    endani = endani + temp[i][j];
                }
            }
            if(endani==16){
                clearInterval(intervalId);
                console.log("끝");
                checkmove();
            }
        }

        function upAnimation(){ // Q.2 위쪽 방향키를 누를경우 이동되는 블럭들을 애니메이션으로 출력해주는 커맨드
            onoff = true;
            blocks = document.getElementsByClassName("block");
            
            var endani = 0;

            for(let j= 0; j<4;j++){
                for(let i= 0; i<4;i++){
                    moveComplete[i][j] = 20+(150*moveXAfter[i][j]);
                }
            }

            for(let j= 0; j<4;j++){
                for(let i= 0; i<4;i++){
                    if(check[i][j]!=0){
                        if(moveTpx[i][j]>=(moveComplete[i][j]+1)){
                            moveTpx[i][j] = moveTpx[i][j]-10;
                            blocks[(i*4)+j].style.top = moveTpx[i][j];
                            console.log("이동중");
                        }else{
                            temp[i][j] = 1;
                        }  
                    }else{
                        temp[i][j] = 1;
                    }
                    endani = endani + temp[i][j];
                }
            }
            if(endani==16){
                clearInterval(intervalId);
                console.log("끝");
                checkmove();
            }
        }

        function downAnimation(){ // Q.2 아래쪽 방향키를 누를경우 이동되는 
                                  // 블럭들을 애니메이션으로 출력해주는 커맨드
            onoff = true;
            blocks = document.getElementsByClassName("block");
            
            var endani = 0;

            for(let j= 0; j<4;j++){
                for(let i= 0; i<4;i++){
                    moveComplete[i][j] = 20+(150*moveXAfter[i][j]);
                }
            }

            for(let j= 0; j<4;j++){
                for(let i= 0; i<4;i++){
                    if(check[i][j]!=0){
                        if(moveTpx[i][j]<=(moveComplete[i][j]-1)){
                            moveTpx[i][j] = moveTpx[i][j]+10;
                            blocks[(i*4)+j].style.top = moveTpx[i][j];
                            console.log("이동중");
                        }else{
                            temp[i][j] = 1;
                        }  
                    }else{
                        temp[i][j] = 1;
                    }
                    endani = endani + temp[i][j];
                }
            }
            if(endani==16){
                clearInterval(intervalId);
                console.log("끝");
                checkmove();
            }
        }
        
        function newdrawAnimation(){ //Q.2 새로운 블럭이 생성될때 애니메이션으로 출력해주는 커맨드
            var endani = 0;
            onoff = true;
            for(let x = 0; x < 4 ; x++){
                for(let y = 0; y < 4; y++){
                    if(checkblock[x][y]!=board[x][y]){
                        if(scaleblock[x][y]<119){
                            console.log(board);
                            if(board[x][y] == 2){
                                blocks[(x*4)+y].style.backgroundColor = '#FFD8D8';
                            }else{   
                                blocks[(x*4)+y].style.backgroundColor = '#FAE0C8';
                            }
                            blocks[(x*4)+y].style.display = 'block';
                            blocks[(x*4)+y].style.width = scaleblock[x][y] + 5;
                            blocks[(x*4)+y].style.height = scaleblock[x][y] + 5;
                            scaleblock[x][y] = scaleblock[x][y] + 5;   
                        }else{
                            temp[x][y] = 1;
                        }          
                    }else{
                        temp[x][y] = 1;
                    }endani = endani + temp[x][y];
                }
            }
            if(endani==16){
                clearInterval(intervalId);
                console.log("끝");
                console.log(board);
                draw();
            }
        }
    
        function openfile(){ 
        // Q.1 & Q.2 
        // html파일 실행시 class = 'block' div를 16개 생성해 blocks배열에 넣어주고,
        // id = 'app'의 div에 추가해주는 커맨드. 
        // 이후 blocks 배열로 사용할 div를 참조하고 더이상 id = 'block' div를 생성하지 않는다. 
        // 사용하지 않는 div는 style none해준다
            for(let i= 0; i<4;i++){
                for(let j= 0; j<4;j++){
                    var app = document.getElementById('app');
                    var div = document.createElement('div');
                    div.className = 'block';
                    app.appendChild(div); 
                }
            }
        blocks = document.getElementsByClassName("block");
        }

        function keydown(e){ 
            // Q.2 키를 누를경우 해당키에 대한 커맨드를 실행시키는 커맨드이자 
            // 사실상 gameloop 순차적으로 커맨드가 실행되며, 
            // 커맨드가 다 실행되기 전까지 한번더 실행되지 않도록 막는다.
            if(onoff==false){
                onoff = true;
                console.log(e.key);
            endG();
            if(gamestate==true){
                compute(e.key);
            }
            endG();
            }
        }

        function keyup(){ // Q.2 키를 땔경우 커맨드가 다 실행되었다면 다시 키를 입력할 수 있도록 해주는 커맨드
            onoff=false;
        }

window.onkeydown = keydown; 
window.onkeyup = keyup;

    </script>
    
</body>
</html>
